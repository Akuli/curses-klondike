import "./card.jou"
import "./state.jou"
import "./klondike.jou"


def place_to_card_x(klon: Klondike*, place: Card**) -> int:
    if place == &klon->stock:
        return 0
    if place == &klon->discard:
        return 1
    if klon->is_tableau(place):
        return klon->tableau_number(place)
    if klon->is_foundation(place):
        return 3 + klon->foundation_number(place)
    assert False


def card_x_to_top_place(klon: Klondike*, x: int) -> Card**:
    match x:
        case 0:
            return &klon->stock
        case 1:
            return &klon->discard
        case 3 | 4 | 5 | 6:
            return &klon->foundations[x-3]
        case _:
            assert False


# returns true if something was done, false otherwise
@public
def select_more(app_state: AppState*) -> bool:
    if app_state->move_dest != NULL:
        return False

    if app_state->klon.is_tableau(app_state->sel_place):
        for card = *app_state->sel_place; card != NULL and card->next != NULL; card = card->next:
            if app_state->sel_card == card->next and card->visible:
                app_state->sel_card = card
                return True
    return False


# returns true if something was done, false otherwise
@public
def select_less(app_state: AppState*) -> bool:
    if app_state->move_dest != NULL:
        return False

    if app_state->sel_card != NULL and app_state->sel_card->next != NULL:
        app_state->sel_card = app_state->sel_card->next
        return True
    return False


# TODO: inline this function? it looks stupid
@public
def select_top_card_or_move_to(app_state: AppState*, place: Card**) -> None:
    assert place != NULL

    if app_state->move_dest == NULL:
        # Select top card
        app_state->sel_place = place
        if place == &app_state->klon.stock:
            # Doesn't make sense to select a card in stock, that also messes with UI
            app_state->sel_card = NULL
        else:
            app_state->sel_card = cardlist_top(*place)
    else:
        # Set where we move it
        app_state->move_dest = place


@public
enum SelDirection:
    Left
    Right
    Up
    Down


@public
def select_another_card(app_state: AppState*, dir: SelDirection) -> None:
    if app_state->move_dest != NULL:
        assert app_state->sel_card != NULL

    if app_state->move_dest != NULL:
        x = place_to_card_x(&app_state->klon, app_state->move_dest)
        is_bottom_row = app_state->klon.is_tableau(app_state->move_dest)
    else:
        x = place_to_card_x(&app_state->klon, app_state->sel_place)
        is_bottom_row = app_state->klon.is_tableau(app_state->sel_place)

    match dir:
        case SelDirection.Left | SelDirection.Right:
            if dir == SelDirection.Left:
                dx = -1
            else:
                dx = 1
            x += dx
            if x == 2 and not is_bottom_row:
                # between discard and tableau
                x += dx

            if 0 <= x and x < 7:
                if is_bottom_row:
                    new_place = &app_state->klon.tableau[x]
                else:
                    new_place = card_x_to_top_place(&app_state->klon, x)
                if app_state->move_dest == NULL or is_bottom_row or app_state->klon.is_foundation(new_place):
                    select_top_card_or_move_to(app_state, new_place)

        case SelDirection.Up:
            if is_bottom_row and x != 2:
                top_place = card_x_to_top_place(&app_state->klon, x)
                # can only move from table to foundations, but multiple cards not even there
                if (
                    app_state->move_dest == NULL
                    or (app_state->klon.is_foundation(top_place) and app_state->sel_card->next == NULL)
                ):
                    select_top_card_or_move_to(app_state, top_place)

        case SelDirection.Down:
            if app_state->move_dest != NULL or not is_bottom_row:
                select_top_card_or_move_to(app_state, &app_state->klon.tableau[x])


@public
def begin_move(app_state: AppState*) -> None:
    assert app_state->move_dest == NULL
    assert app_state->sel_card != NULL
    app_state->move_dest = app_state->sel_place


# moves card if possible
@public
def end_move(app_state: AppState*) -> None:
    assert app_state->move_dest != NULL
    assert app_state->sel_card != NULL
    place = app_state->move_dest
    app_state->move_dest = NULL

    if app_state->klon.can_move(app_state->sel_card, place):
        app_state->klon.move(app_state->sel_card, place, False)

    select_top_card_or_move_to(app_state, place)
