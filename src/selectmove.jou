import "./card.jou"
import "./klondike.jou"


def place_to_card_x(klon: Klondike*, place: Card**) -> int:
    if place == &klon->stock:
        return 0
    if place == &klon->discard:
        return 1
    if klon->is_tableau(place):
        return klon->tableau_number(place)
    if klon->is_foundation(place):
        return 3 + klon->foundation_number(place)
    assert False


def card_x_to_top_place(klon: Klondike*, x: int) -> Card**:
    match x:
        case 0:
            return &klon->stock
        case 1:
            return &klon->discard
        case 3 | 4 | 5 | 6:
            return &klon->foundations[x-3]
        case _:
            assert False


def get_visible_top_card(klon: Klondike*, place: Card**) -> Card*:
    if place == &klon->stock:
        return NULL
    return cardlist_top(*place)


@public
enum SelDirection:
    Left
    Right
    Up
    Down

# Represents the card pile or location that the user has selected.
#
# A pointer to Card is not enough because it's possible to select a place where
# cards can be put but currently contains no cards.
@public
class Selection:
    card: Card*
    place: Card**  # must be one of: &stock, &discard, &foundations[i], &tableau[i]

    # returns true if something was done, false otherwise
    def select_more(self, klon: Klondike*) -> bool:
        if klon->is_tableau(self->place):
            for card = *self->place; card != NULL and card->next != NULL; card = card->next:
                if self->card == card->next and card->visible:
                    self->card = card
                    return True

        return False

    # returns true if something was done, false otherwise
    def select_less(self, klon: Klondike*) -> bool:
        if (
            klon->is_tableau(self->place)
            and self->card != NULL
            and self->card->next != NULL
        ):
            self->card = self->card->next
            return True
        return False


# Represents card being moved src --> dest.
# When multiple cards move, that happens through the `->next` pointer.
class Move:
    card: Card*
    src: Card**     # must be one of: &stock, &discard, &foundations[i], &tableau[i]
    dest: Card**    # must be one of: &stock, &discard, &foundations[i], &tableau[i]


@public
class SelectionOrMove:
    is_move: bool
    # Not a union, canceling with Esc key reverts back to what was selected
    selection: Selection
    move: Move

    def select_top_card_or_move_to(self, klon: Klondike*, place: Card**) -> None:
        if self->is_move:
            self->move.dest = place
        else:
            self->selection = Selection{card = get_visible_top_card(klon, place), place = place}

    def select_another_card(self, klon: Klondike*, dir: SelDirection) -> None:
        if self->is_move:
            assert self->move.card != NULL

        if self->is_move:
            x = place_to_card_x(klon, self->move.dest)
            is_bottom_row = klon->is_tableau(self->move.dest)
        else:
            x = place_to_card_x(klon, self->selection.place)
            is_bottom_row = klon->is_tableau(self->selection.place)

        match dir:
            case SelDirection.Left | SelDirection.Right:
                if dir == SelDirection.Left:
                    dx = -1
                else:
                    dx = 1
                x += dx
                if x == 2 and not is_bottom_row:
                    # between discard and tableau
                    x += dx

                if 0 <= x and x < 7:
                    if is_bottom_row:
                        new_place = &klon->tableau[x]
                    else:
                        new_place = card_x_to_top_place(klon, x)
                    if (not self->is_move) or is_bottom_row or klon->is_foundation(new_place):
                        self->select_top_card_or_move_to(klon, new_place)

            case SelDirection.Up:
                if is_bottom_row and x != 2:
                    top_place = card_x_to_top_place(klon, x)
                    # can only move from table to foundations, but multiple cards not even there
                    if (
                        (not self->is_move)
                        or (klon->is_foundation(top_place) and self->move.card->next == NULL)
                    ):
                        self->select_top_card_or_move_to(klon, top_place)

            case SelDirection.Down:
                if self->is_move or not is_bottom_row:
                    self->select_top_card_or_move_to(klon, &klon->tableau[x])

    def begin_move(self) -> None:
        card = self->selection.card
        place = self->selection.place
        self->is_move = True
        self->move.card = card
        self->move.src = place
        self->move.dest = place

    # moves card if possible
    def end_move(self, klon: Klondike*) -> None:
        assert self->is_move
        assert self->move.card != NULL
        if klon->can_move(self->move.card, self->move.dest):
            klon->move(self->move.card, self->move.dest, False)

        place = self->move.dest
        self->is_move = False
        self->select_top_card_or_move_to(klon, self->move.dest)
