import "./card.jou"
import "./klondike.jou"


def place_to_card_x(place: CardPlace) -> int:
    match place.kind:
        case CardPlaceKind.Tableau:
            return place.number
        case CardPlaceKind.Foundation:
            return 3 + place.number
        case CardPlaceKind.Stock:
            return 0
        case CardPlaceKind.Discard:
            return 1


def card_x_to_top_place(x: int) -> CardPlace:
    match x:
        case 0:
            return CardPlace{kind = CardPlaceKind.Stock}
        case 1:
            return CardPlace{kind = CardPlaceKind.Discard}
        case 3 | 4 | 5 | 6:
            return CardPlace{kind = CardPlaceKind.Foundation, number = x-3}
        case _:
            assert False


def get_visible_top_card(klon: Klondike, place: CardPlace) -> Card*:
    match place.kind:
        case CardPlaceKind.Foundation:
            return cardlist_top(klon.foundations[place.number])
        case CardPlaceKind.Tableau:
            return cardlist_top(klon.tableau[place.number])
        case CardPlaceKind.Discard:
            return cardlist_top(klon.discard)
        case CardPlaceKind.Stock:
            return NULL


enum SelDirection:
    Left
    Right
    Up
    Down

# Represents the card pile or location that the user has selected.
#
# A pointer to Card is not enough because it's possible to select a place where
# cards can be put but currently contains no cards.
#
# Possible values:
#
#    card = NULL, place = stock
#        stock selected
#
#    card = cardlist_top(klon.discard), place = discard
#        discard selected
#
#    card = cardlist_top(klon.foundations[n]), place = foundation n
#        nth foundation selected
#
#    card = klon.tableau[n] or some of its ->nexts, card is visible, place = tableau n
#        nth tableau selected, including the specified card and all its ->nexts
#
#    card = NULL, place = tableau n
#        tableau n selected, but there are no cards in that tableau
@public
class Selection:
    card: Card*
    place: CardPlace

    # returns true if something was done, false otherwise
    def select_more(self, klon: Klondike*) -> bool:
        if self->place.kind == CardPlaceKind.Tableau:
            for card = klon->tableau[self->place.number]; card != NULL and card->next != NULL; card++:
                if self->card == card->next and card->visible:
                    self->card = card
                    return True

        return False

    # returns true if something was done, false otherwise
    def select_less(self, klon: Klondike*) -> bool:
        if (
            self->place.kind == CardPlaceKind.Tableau
            and self->card != NULL
            and self->card->next != NULL
        ):
            self->card = self->card->next
            return True
        return False


# represents card being moved src --> dest
class Move:
    card: Card*
    src: CardPlace
    dest: CardPlace


@public
class SelectionOrMove:
    is_move: bool
    union:
        selection: Selection
        move: Move

    def select_top_card_or_move_to(self, klon: Klondike*, place: CardPlace) -> None:
        if self->is_move:
            self->move.dest = place
        else:
            self->selection = Selection{card = get_visible_top_card(*klon, place), place = place}

    def select_another_card(self, klon: Klondike*, dir: SelDirection) -> None:
        if self->is_move:
            assert self->move.card != NULL

        if self->is_move:
            x = place_to_card_x(self->move.dest)
            is_bottom_row = self->move.dest.kind == CardPlaceKind.Tableau
        else:
            x = place_to_card_x(self->selection.place)
            is_bottom_row = self->selection.place.kind == CardPlaceKind.Tableau

        match dir:
            case SelDirection.Left | SelDirection.Right:
                if dir == SelDirection.Left:
                    dx = -1
                else:
                    dx = 1
                x += dx
                if x == 2 and not is_bottom_row:
                    # between discard and tableau
                    x += dx

                if 0 <= x and x < 7:
                    if is_bottom_row:
                        new_place = CardPlace{kind = CardPlaceKind.Tableau, number = x}
                    else:
                        new_place = card_x_to_top_place(x)
                    if (not self->is_move) or is_bottom_row or new_place.kind == CardPlaceKind.Foundation:
                        self->select_top_card_or_move_to(klon, new_place)

            case SelDirection.Up:
                if is_bottom_row and x != 2:
                    top_place = card_x_to_top_place(x)
                    # can only move from table to foundations, but multiple cards not even there
                    if (
                        (not self->is_move)
                        or (top_place.kind == CardPlaceKind.Foundation and self->move.card->next == NULL)
                    ):
                        self->select_top_card_or_move_to(klon, top_place)

            case SelDirection.Down:
                if self->is_move or not is_bottom_row:
                    self->select_top_card_or_move_to(klon, CardPlace{kind = CardPlaceKind.Tableau, number = x})

    def begin_move(self) -> None:
        card = self->selection.card
        place = self->selection.place
        self->is_move = True
        self->move.card = card
        self->move.src = place
        self->move.dest = place

    # moves card if possible
    def end_move(self, klon: Klondike*) -> None:
        assert self->is_move
        assert self->move.card != NULL
        if klon->can_move(self->move.card, self->move.dest):
            klon->move(self->move.card, self->move.dest, False)

        place = self->move.dest
        self->is_move = False
        self->select_top_card_or_move_to(klon, self->move.dest)
