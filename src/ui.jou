import "stdlib/str.jou"

import "./state.jou"
import "./klondike.jou"
import "./curses.jou"
import "./card.jou"


const CARD_WIDTH: int = 7
const CARD_HEIGHT: int = 5

# offsets for laying out cards so that they overlap
const X_OFFSET: int = 3
const Y_OFFSET_SMALL: int = 1
const Y_OFFSET_BIG: int = 2


# https://en.wikipedia.org/wiki/Box-drawing_character#Unicode
class Border:
    horizontal: byte*
    vertical: byte*
    upper_left: byte*
    upper_right: byte*
    lower_left: byte*
    lower_right: byte*


# TODO: use `const` when that becomes possible
def normal_border() -> Border:
    return Border{
        horizontal="─",
        vertical="│",
        upper_left="╭",
        upper_right="╮",
        lower_left="╰",
        lower_right="╯",
    }

def selected_border() -> Border:
    return Border{
        horizontal="═",
        vertical="║",
        upper_left="╔",
        upper_right="╗",
        lower_left="╚",
        lower_right="╝",
    }


# curses box() is annoyingly for subwindows only
class Box:
    left: int
    top: int
    width: int
    height: int
    selected: bool

    def right(self) -> int:
        return self->left + self->width

    def bottom(self) -> int:
        return self->top + self->height

    def draw(self, window: WINDOW*, background: byte) -> None:
        if self->selected:
            border = selected_border()
        else:
            border = normal_border()

        mvwaddstr(window, self->top, self->left, border.upper_left)
        for x = self->left + 1; x < self->right() - 1; x++:
            mvwaddstr(window, self->top, x, border.horizontal)
        mvwaddstr(window, self->top, self->right()-1, border.upper_right)

        for y = self->top+1; y < self->bottom() - 1; y++:
            mvwaddstr(window, y, self->left, border.vertical)
            for x = self->left + 1; x < self->right() - 1; x++:
                # TODO: use mvwaddch() instead?
                s = [background, '\0']
                mvwaddstr(window, y, x, s)
            mvwaddstr(window, y, self->right() - 1, border.vertical)

        mvwaddstr(window, self->bottom() - 1, self->left, border.lower_left)
        for x = self->left + 1; x < self->right() - 1; x++:
            mvwaddstr(window, self->bottom() - 1, x, border.horizontal)
        mvwaddstr(window, self->bottom() - 1, self->right() - 1, border.lower_right)


# ui_x() and ui_y() convert coordinates from card counts to curses coordinates
def ui_x(x_count: int) -> int:
    # Evenly spaced 7 columns, each column's width is CARD_WIDTH/2
    #
    # space per column = terminal_width/7
    # center of column = space per column * (x_count + 1/2)
    # result = center of column - CARD_WIDTH/2
    #
    # Simplifying it gives this.
    return ((2*x_count + 1)*getmaxx(stdscr) - 7*CARD_WIDTH) / (2*7)

def ui_y(y_count: int) -> int:
    return y_count * CARD_HEIGHT


# newwin() doesn't work because partially erasing borders is surprisingly tricky
# partial erasing is needed for cards that are on top of cards
# since we can't use subwindow borders, they're not very helpful
def draw_card(app_state: AppState*, card: Card*, left: int, top: int, selected: bool) -> None:
    box = Box{left=left, top=top, width=CARD_WIDTH, height=CARD_HEIGHT, selected=selected}
    if card != NULL or selected:
        if card != NULL and not card->visible:
            background = '?'
        else:
            background = ' '
        box.draw(stdscr, background)

    if card != NULL and card->visible:
        attributes = COLOR_PAIR(color_pair_number(suit_to_color(card->suit)))
        if app_state->args.color:
            wattron(stdscr, attributes)

        number_string = card_number_to_string(card->number)
        suit_string = suit_to_string(card->suit)
        mvaddstr(top+1, left+1, number_string)
        mvaddstr(box.bottom()-2, box.right() - 1 - (strlen(number_string) as int), number_string)
        mvaddstr(top+1, box.right()-2, suit_string)
        mvaddstr(box.bottom()-2, left+1, suit_string)

        if app_state->args.color:
            wattroff(stdscr, attributes)


# For iterating through cards at a certain place. Takes moves into account.
#
# Usage:
#
#   card: Card* = NULL
#   while next_card(app_state, place, &card):
#       ...
def next_card(app_state: AppState*, place: CardPlace, card: Card**) -> bool:
    match place.kind:
        case CardPlaceKind.Stock:
            first_card_at_place = app_state->klon.stock
        case CardPlaceKind.Discard:
            first_card_at_place = app_state->klon.discard
        case CardPlaceKind.Foundation:
            first_card_at_place = app_state->klon.foundations[place.number]
        case CardPlaceKind.Tableau:
            first_card_at_place = app_state->klon.tableau[place.number]

    if app_state->selmv.is_move:
        moving_card = app_state->selmv.move.card
        assert moving_card != NULL
    else:
        moving_card = NULL

    if (
        app_state->selmv.is_move
        and not app_state->selmv.move.src.equals(app_state->selmv.move.dest)
        and place.equals(app_state->selmv.move.src)
    ):
        # Cards are being moved away from here. Iterate until we hit the moving card.
        if *card == NULL:
            *card = first_card_at_place
        else:
            *card = (*card)->next

        if *card == moving_card:
            *card = NULL

    elif (
        app_state->selmv.is_move
        and not app_state->selmv.move.src.equals(app_state->selmv.move.dest)
        and place.equals(app_state->selmv.move.dest)
    ):
        # Cards are being moved here. Iterate first the cards that are already
        # here, then the moving cards.
        moving_card = app_state->selmv.move.card
        assert moving_card != NULL

        if *card == NULL:
            if first_card_at_place != NULL:
                *card = first_card_at_place
            else:
                # We only have moving cards, let's go through them
                *card = moving_card
        elif *card == cardlist_top(first_card_at_place):
            # Switch to going through moving cards
            *card = moving_card
        else:
            *card = (*card)->next

    else:
        # No relevant moves. Normal linked list iteration.
        if *card == NULL:
            *card = first_card_at_place
        else:
            *card = (*card)->next

    return *card != NULL


# This function handles:
#   - Overflow: If there's not enough room to show all cards, we "compress"
#     them and show only a little bit.
#   - Moving cards: we want to show the state as if the move happened, even
#     though it didn't really happen yet.
def draw_card_stack(app_state: AppState*, place: CardPlace, skip_count: int, left: int, top: int, first_selected: Card*) -> None:
    starting_card: Card* = NULL
    while skip_count --> 0:
        next_card(app_state, place, &starting_card)

    # How many cards are we going to draw?
    # TODO: moving
    card = starting_card
    n = 0
    while next_card(app_state, place, &card):
        n++

    if n <= 0:
        return

    # The text (number and suit) of bottom_card is at top+1.
    # Let's figure out where it is for the topmost card.
    top_text_y = top + 1 + (n-1) * Y_OFFSET_BIG

    # We can make all cards visible by displaying some cards with a smaller offset.
    # We'll display visible_card_count cards with the bigger offset.
    visible_card_count = n-1
    while top_text_y >= getmaxy(stdscr):
        top_text_y -= Y_OFFSET_BIG
        top_text_y += Y_OFFSET_SMALL
        visible_card_count--

    # to give some extra room that wouldn't be really necessary, but is nicer.
    # Without the if, cards get stacked even when there's enough room.
    # TODO: I don't like this behaviour anymore, change it
    if visible_card_count != n-1:
        visible_card_count--

    # Let's draw the cards
    selected = False
    y = top
    card = starting_card
    while next_card(app_state, place, &card):
        if card == first_selected:
            selected = True
        draw_card(app_state, card, left, y, selected)
        if visible_card_count --> 0:
            y += Y_OFFSET_BIG
        else:
            y += Y_OFFSET_SMALL


# See https://github.com/Akuli/curses-klondike/issues/2
enum DiscardHide:
    HideAll
    ShowLastOnly
    ShowAll

def decide_what_to_hide(app_state: AppState*) -> DiscardHide:
    if not app_state->args.discardhide:
        return DiscardHide.ShowAll

    if not app_state->selmv.is_move:
        return DiscardHide.ShowLastOnly

    if app_state->selmv.move.src.is_discard():
        if app_state->selmv.move.dest.is_discard():
            # Move from discard to discard, show as if not moving at all
            return DiscardHide.ShowLastOnly
        else:
            # Visible card is being moved from discard somewhere else, show nothing more
            return DiscardHide.HideAll

    return DiscardHide.ShowLastOnly


def draw_discard(app_state: AppState*) -> None:
    if (
        app_state->selmv.is_move
        and app_state->selmv.move.src.is_discard()
        and not app_state->selmv.move.dest.is_discard()
    ):
        # A card is being moved out of discard. Do not show it.
        end_of_iteration = app_state->selmv.move.card
    else:
        end_of_iteration = NULL

    if app_state->selmv.is_move:
        select_last = app_state->selmv.move.dest.is_discard()
    else:
        select_last = app_state->selmv.selection.place.is_discard()

    x = ui_x(1)
    for card = cardlist_top_n(app_state->klon.discard, app_state->klon.discardshow); card != end_of_iteration; card = card->next:
        # TODO: perhaps shouldn't need to make a temp copy?
        temp = *card
        assert temp.visible
        match decide_what_to_hide(app_state):
            case DiscardHide.ShowAll:
                temp.visible = True
            case DiscardHide.HideAll:
                temp.visible = False
            case DiscardHide.ShowLastOnly:
                temp.visible = card->next == end_of_iteration

        draw_card(app_state, &temp, x, ui_y(0), card->next == end_of_iteration and select_last)
        if app_state->args.discardhide:
            x++
        else:
            x += X_OFFSET

    if app_state->klon.discard == NULL:
        # nothing was drawn yet, show where discarded cards would be
        draw_card(app_state, NULL, ui_x(1), ui_y(0), app_state->selmv.selection.place.is_discard())


def draw_tableau(app_state: AppState*) -> None:
    for x = 0; x < 7; x++:
        if app_state->klon.tableau[x] == NULL:
            # draw a border if the tableau item is selected
            draw_card(
                app_state,
                NULL,
                ui_x(x),
                ui_y(1),
                app_state->selmv.selection.place.is_tableau(x)
            )
            continue

        n = 0
        for card = app_state->klon.tableau[x]; card != NULL; card = card->next:
            if card->visible:
                draw_card_stack(
                    app_state,
                    CardPlace{kind = CardPlaceKind.Tableau, number = x},
                    n,
                    ui_x(x),
                    ui_y(1) + n*Y_OFFSET_SMALL,
                    app_state->selmv.selection.card,
                )
                break

            draw_card(app_state, card, ui_x(x), ui_y(1) + n*Y_OFFSET_SMALL, False)
            n++


@public
def draw_klondike(app_state: AppState*) -> None:
    werase(stdscr)

    draw_card(app_state, app_state->klon.stock, ui_x(0), ui_y(0), app_state->selmv.selection.place.is_stock())
    draw_discard(app_state)
    for i = 0; i < 4; i++:
        draw_card(
            app_state,
            cardlist_top(app_state->klon.foundations[i]),
            ui_x(3+i),
            ui_y(0),
            app_state->selmv.selection.place.is_foundation(i)
        )
    draw_tableau(app_state)

    if app_state->klon.win():
        msg = "you win :)"
        msg_width = strlen(msg) as int
        mvwaddstr(stdscr, getmaxy(stdscr)/2, (getmaxx(stdscr) - msg_width)/2, msg)
