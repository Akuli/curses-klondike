import "stdlib/str.jou"
import "stdlib/math.jou"
import "stdlib/mem.jou"

import "./state.jou"
import "./klondike.jou"
import "./curses.jou"
import "./card.jou"


const CARD_WIDTH: int = 7
const CARD_HEIGHT: int = 5

# offsets for laying out cards so that they overlap
const X_OFFSET: int = 3
const Y_OFFSET_SMALL: int = 1
const Y_OFFSET_BIG: int = 2


def card_sized_box(left: int, top: int, thick: bool, fill: byte*) -> None:
    right = left + CARD_WIDTH
    bottom = top + CARD_HEIGHT

    # https://en.wikipedia.org/wiki/Box-drawing_character#Unicode
    if thick:
        horizontal = "═"
        vertical = "║"
        upper_left = "╔"
        upper_right = "╗"
        lower_left = "╚"
        lower_right = "╝"
    else:
        horizontal = "─"
        vertical = "│"
        upper_left = "╭"
        upper_right = "╮"
        lower_left = "╰"
        lower_right = "╯"

    mvaddstr(top, left, upper_left)
    for x = left + 1; x < right - 1; x++:
        mvaddstr(top, x, horizontal)
    mvaddstr(top, right - 1, upper_right)

    for y = top + 1; y < bottom - 1; y++:
        mvaddstr(y, left, vertical)
        for x = left + 1; x < right - 1; x++:
            mvaddstr(y, x, fill)
        mvaddstr(y, right - 1, vertical)

    mvaddstr(bottom - 1, left, lower_left)
    for x = left + 1; x < right - 1; x++:
        mvaddstr(bottom - 1, x, horizontal)
    mvaddstr(bottom - 1, right - 1, lower_right)


# ui_x() and ui_y() convert coordinates from card counts to curses coordinates
def ui_x(x_count: int) -> int:
    # Evenly spaced 7 columns, each column's width is CARD_WIDTH/2
    #
    # space per column = terminal_width/7
    # center of column = space per column * (x_count + 1/2)
    # result = center of column - CARD_WIDTH/2
    #
    # Simplifying it gives this.
    return ((2*x_count + 1)*getmaxx(stdscr) - 7*CARD_WIDTH) / (2*7)

def ui_y(y_count: int) -> int:
    return y_count * CARD_HEIGHT


# newwin() doesn't work because partially erasing borders is surprisingly tricky
# partial erasing is needed for cards that are on top of cards
# since we can't use subwindow borders, they're not very helpful
def draw_card(app_state: AppState*, card: Card*, left: int, top: int, selected: bool) -> None:
    if card != NULL or selected:
        if card != NULL and not card->visible:
            card_sized_box(left, top, selected, "?")
        else:
            card_sized_box(left, top, selected, " ")

    if card != NULL and card->visible:
        attributes = COLOR_PAIR(color_pair_number(suit_to_color(card->suit)))
        if app_state->args.color:
            wattron(stdscr, attributes)

        number_string = card_number_to_string(card->number)
        suit_string = suit_to_string(card->suit)
        mvaddstr(top + 1, left + 1, number_string)
        mvaddstr(top + CARD_HEIGHT - 2, left + CARD_WIDTH - 1 - (strlen(number_string) as int), number_string)
        mvaddstr(top + 1, left + CARD_WIDTH - 2, suit_string)
        mvaddstr(top + CARD_HEIGHT - 2, left + 1, suit_string)

        if app_state->args.color:
            wattroff(stdscr, attributes)


# For drawing cards at a certain place.
#
# Places results to the result array. Returns number of cards in it.
def get_cards_after_moves(app_state: AppState*, place: CardPlace, result: Card*[52]*) -> int:
    match place.kind:
        case CardPlaceKind.Stock:
            first_card_at_place = app_state->klon.stock
        case CardPlaceKind.Discard:
            first_card_at_place = app_state->klon.discard
        case CardPlaceKind.Foundation:
            first_card_at_place = app_state->klon.foundations[place.number]
        case CardPlaceKind.Tableau:
            first_card_at_place = app_state->klon.tableau[place.number]

    i = 0

    if (
        app_state->selmv.is_move
        and not app_state->selmv.move.src.equals(app_state->selmv.move.dest)
        and place.equals(app_state->selmv.move.src)
    ):
        # Cards are being moved away from here. Stop at the moving card.
        for c = first_card_at_place; c != NULL; c = c->next:
            if c == app_state->selmv.move.card:
                break
            (*result)[i++] = c
    elif (
        app_state->selmv.is_move
        and not app_state->selmv.move.src.equals(app_state->selmv.move.dest)
        and place.equals(app_state->selmv.move.dest)
    ):
        # Cards are being moved here. Add moved cards to end of result.
        for c = first_card_at_place; c != NULL; c = c->next:
            (*result)[i++] = c
        for c = app_state->selmv.move.card; c != NULL; c = c->next:
            (*result)[i++] = c
    else:
        # Moves are irrelevant
        for c = first_card_at_place; c != NULL; c = c->next:
            (*result)[i++] = c

    assert i < sizeof(*result) / sizeof((*result)[0])
    return i


# This function handles:
#   - Overflow: If there's not enough room to show all cards, we "compress"
#     them and show only a little bit.
#   - Moving cards: we want to show the state as if the move happened, even
#     though it didn't really happen yet.
def draw_card_stack(app_state: AppState*, place: CardPlace, skip_count: int, left: int, top: int, first_selected: Card*) -> None:
    cards: Card*[52]
    ncards = get_cards_after_moves(app_state, place, &cards)

    skip_count = min(skip_count, ncards)
    memmove(&cards[skip_count], &cards[0], sizeof(cards[0]) * (ncards - skip_count))
    ncards -= skip_count

    if ncards == 0:
        return

    # The text (number and suit) of bottom_card is at top+1.
    # Let's figure out where it is for the topmost card.
    top_text_y = top + 1 + (ncards-1) * Y_OFFSET_BIG

    # We can make all cards visible by displaying some cards with a smaller offset.
    # We'll display visible_card_count cards with the bigger offset.
    visible_card_count = ncards-1
    while top_text_y >= getmaxy(stdscr):
        top_text_y -= Y_OFFSET_BIG
        top_text_y += Y_OFFSET_SMALL
        visible_card_count--

    # to give some extra room that wouldn't be really necessary, but is nicer.
    # Without the if, cards get stacked even when there's enough room.
    # TODO: I don't like this behaviour anymore, change it
    if visible_card_count != ncards-1:
        visible_card_count--

    # Let's draw the cards
    selected = False
    y = top
    for i = 0; i < ncards; i++:
        if cards[i] == first_selected:
            selected = True
        draw_card(app_state, cards[i], left, y, selected)
        if visible_card_count --> 0:
            y += Y_OFFSET_BIG
        else:
            y += Y_OFFSET_SMALL


# See https://github.com/Akuli/curses-klondike/issues/2
enum DiscardHide:
    HideAll
    ShowLastOnly
    ShowAll

def decide_what_to_hide(app_state: AppState*) -> DiscardHide:
    if not app_state->args.discardhide:
        return DiscardHide.ShowAll

    if not app_state->selmv.is_move:
        return DiscardHide.ShowLastOnly

    if app_state->selmv.move.src.is_discard():
        if app_state->selmv.move.dest.is_discard():
            # Move from discard to discard, show as if not moving at all
            return DiscardHide.ShowLastOnly
        else:
            # Visible card is being moved from discard somewhere else, show nothing more
            return DiscardHide.HideAll

    return DiscardHide.ShowLastOnly


def draw_discard(app_state: AppState*) -> None:
    cards: Card*[52]
    ncards = get_cards_after_moves(app_state, CardPlace{kind = CardPlaceKind.Discard}, &cards)

    # Show only the discarded cards that are meant to be visible.
    #
    # Getting this to work in all situations is tricky:
    #   - No move
    #   - A move, but not from discard (same as no moves)
    #   - A move from discard to discard (same as no moves)
    #   - A move from discard to somewhere else, no cards remain in discard
    #   - A move from discard to somewhere else, only non-visible cards remain in discard
    #   - A move from discard to somewhere else, visible cards remain in discard
    shown_ncards = min(ncards, app_state->klon.discardshow)

#    if (
#        app_state->selmv.is_move
#        and app_state->selmv.move.src.is_discard()
#        and not app_state->selmv.move.dest.is_discard()
#    ):
#        # A card is being moved out of discard.
#        #
#        # Prevent the pile appearing empty when moving away the last picked
#        # card, but there are more cards below it.
#        
#        if n == 1:
#            n = 2

    if app_state->selmv.is_move:
        select_last = app_state->selmv.move.dest.is_discard()
    else:
        select_last = app_state->selmv.selection.place.is_discard()

    x = ui_x(1)
    for i = ncards - shown_ncards; i < ncards; i++:
        temp_copy = *cards[i]  # TODO: shouldn't be needed
        match decide_what_to_hide(app_state):
            case DiscardHide.ShowAll:
                temp_copy.visible = True
            case DiscardHide.HideAll:
                temp_copy.visible = False
            case DiscardHide.ShowLastOnly:
                temp_copy.visible = (i == ncards - 1)
        draw_card(app_state, &temp_copy, x, ui_y(0), (i == ncards - 1) and select_last)
        if app_state->args.discardhide:
            x++
        else:
            x += X_OFFSET

    if app_state->klon.discard == NULL:
        # nothing was drawn yet, show where discarded cards would be
        draw_card(app_state, NULL, ui_x(1), ui_y(0), app_state->selmv.selection.place.is_discard())


def draw_tableau(app_state: AppState*) -> None:
    for x = 0; x < 7; x++:
        if app_state->klon.tableau[x] == NULL:
            # draw a border if the tableau item is selected
            draw_card(
                app_state,
                NULL,
                ui_x(x),
                ui_y(1),
                app_state->selmv.selection.place.is_tableau(x)
            )
            continue

        n = 0
        for card = app_state->klon.tableau[x]; card != NULL; card = card->next:
            if card->visible:
                draw_card_stack(
                    app_state,
                    CardPlace{kind = CardPlaceKind.Tableau, number = x},
                    n,
                    ui_x(x),
                    ui_y(1) + n*Y_OFFSET_SMALL,
                    app_state->selmv.selection.card,
                )
                break

            draw_card(app_state, card, ui_x(x), ui_y(1) + n*Y_OFFSET_SMALL, False)
            n++


@public
def draw_klondike(app_state: AppState*) -> None:
    werase(stdscr)

    draw_card(app_state, app_state->klon.stock, ui_x(0), ui_y(0), app_state->selmv.selection.place.is_stock())
    draw_discard(app_state)
    for i = 0; i < 4; i++:
        draw_card(
            app_state,
            cardlist_top(app_state->klon.foundations[i]),
            ui_x(3+i),
            ui_y(0),
            app_state->selmv.selection.place.is_foundation(i)
        )
    draw_tableau(app_state)

    if app_state->klon.win():
        msg = "you win :)"
        msg_width = strlen(msg) as int
        mvwaddstr(stdscr, getmaxy(stdscr)/2, (getmaxx(stdscr) - msg_width)/2, msg)
