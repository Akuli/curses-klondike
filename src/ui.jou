import "stdlib/str.jou"

import "./state.jou"
import "./curses.jou"
import "./card.jou"
import "./selectmove.jou"
import "./klondike.jou"


const CARD_WIDTH: int = 7
const CARD_HEIGHT: int = 5

# offsets for laying out cards so that they overlap
const X_OFFSET: int = 3
const Y_OFFSET_SMALL: int = 1
const Y_OFFSET_BIG: int = 2


# https://en.wikipedia.org/wiki/Box-drawing_character#Unicode
class Border:
    horizontal: byte*
    vertical: byte*
    upper_left: byte*
    upper_right: byte*
    lower_left: byte*
    lower_right: byte*


# TODO: use `const` when that becomes possible
def normal_border() -> Border:
    return Border{
        horizontal="─",
        vertical="│",
        upper_left="╭",
        upper_right="╮",
        lower_left="╰",
        lower_right="╯",
    }

def selected_border() -> Border:
    return Border{
        horizontal="═",
        vertical="║",
        upper_left="╔",
        upper_right="╗",
        lower_left="╚",
        lower_right="╝",
    }


# curses box() is annoyingly for subwindows only
class Box:
    left: int
    top: int
    width: int
    height: int
    selected: bool

    def right(self) -> int:
        return self->left + self->width

    def bottom(self) -> int:
        return self->top + self->height

    def draw(self, window: WINDOW*, background: byte) -> None:
        if self->selected:
            border = selected_border()
        else:
            border = normal_border()

        mvwaddstr(window, self->top, self->left, border.upper_left)
        for x = self->left + 1; x < self->right() - 1; x++:
            mvwaddstr(window, self->top, x, border.horizontal)
        mvwaddstr(window, self->top, self->right()-1, border.upper_right)

        for y = self->top+1; y < self->bottom() - 1; y++:
            mvwaddstr(window, y, self->left, border.vertical)
            for x = self->left + 1; x < self->right() - 1; x++:
                # TODO: use mvwaddch() instead?
                s = [background, '\0']
                mvwaddstr(window, y, x, s)
            mvwaddstr(window, y, self->right() - 1, border.vertical)

        mvwaddstr(window, self->bottom() - 1, self->left, border.lower_left)
        for x = self->left + 1; x < self->right() - 1; x++:
            mvwaddstr(window, self->bottom() - 1, x, border.horizontal)
        mvwaddstr(window, self->bottom() - 1, self->right() - 1, border.lower_right)


# See https://github.com/Akuli/curses-klondike/issues/2
enum DiscardHide:
    HideAll
    ShowLastOnly
    ShowAll

def decide_what_to_hide(selmv: SelectionOrMove*, command_line_option: bool) -> DiscardHide:
    if not command_line_option:
        return DiscardHide.ShowAll

    if not selmv->is_move:
        return DiscardHide.ShowLastOnly

    if selmv->move.src.is_discard():
        if selmv->move.dest.is_discard():
            # Move from discard to discard, show as if not moving at all
            return DiscardHide.ShowLastOnly
        else:
            # Visible card is being moved from discard somewhere else, show nothing more
            return DiscardHide.HideAll

    return DiscardHide.ShowLastOnly


class Drawer:
    window: WINDOW*
    klon: Klondike*
    sel: Selection*
    moving: bool
    color: bool
    discard_hide: DiscardHide
    discard_x_offset: int

    def terminal_width(self) -> int:
        return getmaxx(self->window)

    def terminal_height(self) -> int:
        return getmaxy(self->window)

    # ui_x() and ui_y() convert coordinates from card counts to curses coordinates
    def ui_x(self, x_count: int) -> int:
        # evenly spaced 7 columns, centered
        #
        # space per column = terminal_width/7
        # center of column = space per column * (x_count + 1/2)
        # result = center of column - CARD_WIDTH/2
        #
        # Simplifying it gives this.
        return ((2*x_count + 1)*self->terminal_width() - 7*CARD_WIDTH) / (2*7)

    def ui_y(self, y_count: int) -> int:
        return y_count * CARD_HEIGHT

    # newwin() doesn't work because partially erasing borders is surprisingly tricky
    # partial erasing is needed for cards that are on top of cards
    # since we can't use subwindow borders, they're not very helpful
    def draw_card(self, card: Card*, left: int, top: int, selected: bool) -> None:
        box = Box{left=left, top=top, width=CARD_WIDTH, height=CARD_HEIGHT, selected=selected}
        if card != NULL or selected:
            if card != NULL and not card->visible:
                background = '?'
            else:
                background = ' '
            box.draw(self->window, background)

        if card != NULL and card->visible:
            attributes = COLOR_PAIR(color_pair_number(suit_to_color(card->suit)))
            if self->color:
                wattron(self->window, attributes)

            number_string = card_number_to_string(card->number)
            suit_string = suit_to_string(card->suit)
            mvaddstr(top+1, left+1, number_string)
            mvaddstr(box.bottom()-2, box.right() - 1 - (strlen(number_string) as int), number_string)
            mvaddstr(top+1, box.right()-2, suit_string)
            mvaddstr(box.bottom()-2, left+1, suit_string)

            if self->color:
                wattroff(self->window, attributes)

    # Unlike a simple for loop, this handles overflow.
    def draw_card_stack(self, bottom_card: Card*, left: int, top: int, first_selected: Card*) -> None:
        if bottom_card == NULL:
            return

        # The text (number and suit) of bottom_card is at top+1.
        # Let's figure out where it is for the topmost card.
        top_text_y = top+1
        card_count_excluding_bottom = 0
        for card = bottom_card->next; card != NULL; card = card->next:
            top_text_y += Y_OFFSET_BIG
            card_count_excluding_bottom++

        # We can make all cards visible by displaying some cards with a smaller offset.
        # We'll display visible_card_count cards with the bigger offset.
        visible_card_count = card_count_excluding_bottom
        while top_text_y >= self->terminal_height():
            top_text_y -= Y_OFFSET_BIG
            top_text_y += Y_OFFSET_SMALL
            visible_card_count--

        # to give some extra room that wouldn't be really necessary, but is nicer.
        # Without the if, cards get stacked even when there's enough room.
        # TODO: I don't like self behaviour anymore, change it
        if  visible_card_count != card_count_excluding_bottom:
            visible_card_count--

        # Let's draw the cards
        selected = False
        y = top
        for card = bottom_card; card != NULL; card = card->next:
            if card == first_selected:
                selected = True
            self->draw_card(card, left, y, selected)
            if visible_card_count --> 0:
                y += Y_OFFSET_BIG
            else:
                y += Y_OFFSET_SMALL

    def draw_discard(self) -> None:
        show_count = self->klon->discardshow
        if self->sel->place.is_discard() and self->moving:
            show_count++

        x = self->ui_x(1)
        for card = cardlist_top_n(self->klon->discard, show_count); card != NULL; card = card->next:
            temp = *card
            assert temp.visible
            match self->discard_hide:
                case DiscardHide.ShowAll:
                    temp.visible = True
                case DiscardHide.HideAll:
                    temp.visible = False
                case DiscardHide.ShowLastOnly:
                    temp.visible = card->next == NULL

            self->draw_card(&temp, x, self->ui_y(0), self->sel->place.is_discard() and card->next == NULL)
            x += self->discard_x_offset

        if self->klon->discard == NULL:   # nothing was drawn, but if the discard is selected, at least draw that
            self->draw_card(NULL, self->ui_x(1), self->ui_y(0), self->sel->place.is_discard())

    def draw_tableau(self) -> None:
        for x = 0; x < 7; x++:
            if self->klon->tableau[x] == NULL:
                # draw a border if the tableau item is selected
                self->draw_card(
                    NULL,
                    self->ui_x(x),
                    self->ui_y(1),
                    self->sel->place.is_tableau(x)
                )
                continue

            y = self->ui_y(1)
            for card = self->klon->tableau[x]; card != NULL; card = card->next:
                if card->visible:
                    self->draw_card_stack(card, self->ui_x(x), y, self->sel->card)
                    break

                self->draw_card(card, self->ui_x(x), y, False)
                y += Y_OFFSET_SMALL

    def draw_game(self) -> None:
        werase(self->window)

        self->draw_card(self->klon->stock, self->ui_x(0), self->ui_y(0), self->sel->place.is_stock())
        self->draw_discard()
        for i = 0; i < 4; i++:
            self->draw_card(
                cardlist_top(self->klon->foundations[i]),
                self->ui_x(3+i),
                self->ui_y(0),
                self->sel->place.is_foundation(i)
            )
        self->draw_tableau()

        if self->klon->win():
            msg = "you win :)"
            msg_width = strlen(msg) as int
            mvwaddstr(self->window, self->terminal_height()/2, (self->terminal_width() - msg_width)/2, msg)


@public
def draw_klondike(window: WINDOW*, klon: Klondike*, selmv: SelectionOrMove*, args: Args*) -> None:
    discard_hide = decide_what_to_hide(selmv, args->discardhide)
    if args->discardhide:
        discard_x_offset = 1
    else:
        discard_x_offset = X_OFFSET

    drawer = Drawer{
        window=window,
        klon=klon,
        sel=&selmv->selection,
        moving=selmv->is_move,
        color=args->color,
        discard_hide=discard_hide,
        discard_x_offset=discard_x_offset,
    }

    if selmv->is_move:
        # Temporarily create state after the move and show that
        temp_cards: Card[52]
        temp_klon = Klondike{}
        temp_sel = Selection{card=klon->dup(&temp_klon, selmv->move.card, &temp_cards), place=selmv->move.dest}
        temp_klon.move(temp_sel.card, temp_sel.place, True)

        drawer.klon = &temp_klon
        drawer.sel = &temp_sel
        drawer.draw_game()
    else:
        drawer.draw_game()
