import "stdlib/str.jou"
import "stdlib/io.jou"
import "stdlib/process.jou"

import "./curses.jou"
import "./rand.jou"

import "./selectmove.jou"
import "./card.jou"
import "./klondike.jou"
import "./args.jou"
import "./help.jou"
import "./ui.jou"


def curses_key_to_seldirection(key: int) -> SelDirection:
    match key:
        case KEY_LEFT:
            return SelDirection.Left
        case KEY_RIGHT:
            return SelDirection.Right
        case KEY_UP:
            return SelDirection.Up
        case KEY_DOWN:
            return SelDirection.Down
        case _:
            assert False


def new_game(card_array: Card[52]*) -> Game:
    result = Game{card_array = card_array}
    result.klon.init(card_array)
    result.selmv = SelectionOrMove{
        is_move = False,
        selection = Selection{place = CardPlace{kind = CardPlaceKind.Stock}},
    }
    return result


class Game:
    klon: Klondike
    selmv: SelectionOrMove
    card_array: Card[52]*

    def handle_key(self, key: int, args: Args, argv0: byte*) -> None:
        match key:
            ##########################################################################
            ### If you change these, please update the key bindings shown in help! ###
            ##########################################################################
            case 'h':
                show_help(stdscr, argv0, args.color)
            case 's':
                if not self->selmv.is_move:
                    self->klon.stock2discard(args.pick)

                    # if you change this, think about what if the discard card was selected?
                    # then the moved card ended up on top of the old discarded card
                    # and we have 2 cards selected, so you need to handle that
                    self->selmv.select_top_card_or_move_to(&self->klon, CardPlace{kind = CardPlaceKind.Discard})
            case 'd':
                if not self->selmv.is_move:
                    self->selmv.select_top_card_or_move_to(&self->klon, CardPlace{kind = CardPlaceKind.Discard})
            case 'f':
                if (
                    (not self->selmv.is_move)
                    and self->selmv.selection.card != NULL
                    and self->klon.move2foundation(self->selmv.selection.card)
                ):
                    self->selmv.select_top_card_or_move_to(&self->klon, self->selmv.selection.place)
            case 'g':
                if not self->selmv.is_move:
                    # Try discard -> foundation
                    moved = self->klon.move2foundation(cardlist_top(self->klon.discard))
                    if not moved:
                        # Try tableau -> foundation
                        for i = 0; i < 7 and not moved; i++:
                            if self->klon.move2foundation(cardlist_top(self->klon.tableau[i])):
                                moved = True
                                break

                    if moved:
                        # update sel.card if needed
                        self->selmv.select_top_card_or_move_to(&self->klon, self->selmv.selection.place)

            case 27:  # esc key, didn't find a KEY_foo constant for this in curses headers
                self->selmv.is_move = False
            case KEY_UP | KEY_DOWN:
                if (not self->selmv.is_move) and key == KEY_UP and self->selmv.selection.select_more(&self->klon):
                    pass  # Successfully selected more
                elif (not self->selmv.is_move) and key == KEY_UP and self->selmv.selection.select_less(&self->klon):
                    pass  # Successfully selected less
                else:
                    self->selmv.select_another_card(&self->klon, curses_key_to_seldirection(key))
            case KEY_LEFT | KEY_RIGHT:
                self->selmv.select_another_card(&self->klon, curses_key_to_seldirection(key))
            case KEY_PPAGE:
                if not self->selmv.is_move:
                    while self->selmv.selection.select_more(&self->klon):
                        pass
            case KEY_NPAGE:
                if not self->selmv.is_move:
                    while self->selmv.selection.select_less(&self->klon):
                        pass
            case '\n':
                if self->selmv.is_move:
                    self->selmv.end_move(&self->klon)
                elif self->selmv.selection.place.is_stock():
                    self->klon.stock2discard(args.pick)
                elif self->selmv.selection.card != NULL and self->selmv.selection.card->visible:
                    self->selmv.begin_move()
            case '1' | '2' | '3' | '4' | '5' | '6' | '7':
                self->selmv.select_top_card_or_move_to(&self->klon, CardPlace{kind = CardPlaceKind.Tableau, number = key - '1'})


def confirm_yes_no(prompt: byte*) -> bool:
    prompt_len = (strlen(prompt) + strlen(" (y/n)")) as int

    while True:
        width = getmaxx(stdscr)
        height = getmaxy(stdscr)

        werase(stdscr)
        mvwprintw(stdscr, height/2, (width - prompt_len)/2, "%s (y/n)", prompt)
        wrefresh(stdscr)

        match getch():
            case 'y':
                return True
            case 'n':
                return False


def fail(screen_inited: bool, program_name: byte*, msg: byte*) -> noreturn:
    if screen_inited:
        endwin()
    fprintf(stderr, "%s: %s\n", program_name, msg)
    exit(1)


# TODO: move to Jou stdlib?
declare time(ptr: int64*) -> int64
declare setenv(name: byte*, value: byte*, overwrite: int) -> int
declare setlocale(category: int, locale: byte*) -> byte*
const LC_ALL: int = 6  # TODO: probably something else on macos


def main(argc: int, argv: byte**) -> int:
    screen_inited = False

    # displaying unicodes correctly needs setlocale here AND cursesw instead of curses in makefile
    if setlocale(LC_ALL, "") == NULL:
        fail(screen_inited, argv[0], "setlocale() failed")

    srand(time(NULL) as uint32)

    args: Args
    status = parse_args(argv, &args, stdout, stderr)
    if status != CONTINUE_TO_PROGRAM:
        return status

    # https://stackoverflow.com/a/28020568
    # see also ESCDELAY in a man page named "ncurses"
    # setting to "0" works, but feels like a hack, so i used same as in stackoverflow
    if setenv("ESCDELAY", "25", False as int) < 0:
        fail(screen_inited, argv[0], "setenv() failed")

    if initscr() == NULL:
        fail(screen_inited, argv[0], "initscr() failed")
    screen_inited = True

    args.color = (args.color and has_colors() and start_color() != ERR)
    if args.color:
        if init_pair(color_pair_number(Color.Red), COLOR_RED, COLOR_BLACK) == ERR:
            fail(screen_inited, argv[0], "init_pair() failed")
        if init_pair(color_pair_number(Color.Black), COLOR_WHITE, COLOR_BLACK) == ERR:
            fail(screen_inited, argv[0], "init_pair() failed")

    if cbreak() == ERR:
        fail(screen_inited, argv[0], "cbreak() failed")
    if noecho() == ERR:
        fail(screen_inited, argv[0], "noecho() failed")
    if curs_set(0) == ERR:
        fail(screen_inited, argv[0], "curs_set() failed")
    if keypad(stdscr, True) == ERR:
        fail(screen_inited, argv[0], "keypad() failed")

    card_array: Card[52]
    game = new_game(&card_array)

    first = True
    while True:
        draw_klondike(stdscr, &game.klon, &game.selmv, &args)

        if first:
            height = getmaxy(stdscr)
            wattron(stdscr, A_STANDOUT)
            mvwaddstr(stdscr, height-1, 0, "Press h for help.")
            wattroff(stdscr, A_STANDOUT)
            first = False

        refresh()

        key = getch()
        match key:
            case 'q':
                if confirm_yes_no("Do you really want to quit?"):
                    endwin()
                    return 0
            case 'n':
                if confirm_yes_no("Do you really want to start a new game?"):
                    game = new_game(&card_array)
            case _:
                game.handle_key(key, args, argv[0])
