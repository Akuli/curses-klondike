# This file parses command-line arguments.

import "stdlib/ascii.jou"
import "stdlib/io.jou"
import "stdlib/str.jou"
import "stdlib/process.jou"
import "./state.jou"


class ParseState:
    program_name: byte*
    remaining_args: byte**  # never includes program name


enum Option:
    Help
    NoColors
    Pick
    DiscardHide


# TODO: NUM_OPTIONS and option_name() should be replaced by a `const` array of strings.
# That is not supported in Jou yet.
const NUM_OPTIONS: int = 4

def option_name(opt: Option) -> byte*:
    match opt:
        case Option.Help:
            return "--help"
        case Option.NoColors:
            return "--no-colors"
        case Option.Pick:
            return "--pick"
        case Option.DiscardHide:
            return "--discard-hide"


const HELP_TEXT: byte* = "\
Usage: %s [--help] [--no-colors] [--pick n] [--discard-hide]\n\
\n\
Options:\n\
  --help          show this help message and exit\n\
  --no-colors     don't use colors, even if the terminal supports colors\n\
  --pick n        pick n cards from stock at a time, default is 3\n\
  --discard-hide  only show topmost discarded card (not useful with --pick=1)\n\
"


def fail(state: ParseState*) -> noreturn:
    fprintf(stderr, "Run '%s --help' for help.\n", state.program_name)
    exit(2)


def get_option_from_name(state: ParseState*, arg: byte*) -> Option:
    if strlen(arg) < 3 or not starts_with(arg, "--"):
        fprintf(stderr, "%s: unexpected argument: '%s'\n", state.program_name, arg)
        fail(state)

    # Allow abbreviations, e.g. "--no-col" for --no-colors
    for i = 0; i < NUM_OPTIONS; i++:
        if starts_with(option_name(i as Option), arg):
            return i as Option

    fprintf(stderr, "%s: unknown option '%s'\n", state.program_name, arg)
    fail(state)


# Grab one option from args. If the option has an associated value (--pick 3), take that too.
# One option can come from 2 argv items (--pick 3) or just one (--pick=3, --no-colors).
def get_option_and_value(state: ParseState*, opt: Option*, value: byte**) -> None:
    arg = *state.remaining_args++
    assert arg != NULL

    if strlen(arg) < 3 or not starts_with(arg, "--"):
        fprintf(stderr, "%s: unexpected argument: '%s'\n", state.program_name, arg)
        fail(state)

    eq = strstr(arg, "=")
    if eq != NULL:
        *value = &eq[1]
    elif *state.remaining_args == NULL or starts_with(*state.remaining_args, "-"):
        *value = NULL
    else:
        *value = *state.remaining_args++

    # Get rid of value if any, e.g. "--pick=1" --> "--pick"
    name: byte[100]
    snprintf(name, sizeof(name), "%.*s", strcspn(arg, "=") as int, arg)
    *opt = get_option_from_name(state, name)


def check_no_value(state: ParseState*, opt: Option, value: byte*) -> None:
    if value != NULL:
        fprintf(
            stderr, "%s: use just '%s', not '%s something' or '%s=something'\n",
            state.program_name, option_name(opt), option_name(opt), option_name(opt)
        )
        fail(state)


def is_valid_integer(s: byte*, min: int, max: int) -> bool:
    if *s == '\0':
        return False

    for p = s; *p != '\0'; p++:
        if not is_ascii_digit(*p):
            return False

    # This won't work for very large values, but it doesn't really matter :)
    n = atoi(s)
    return min <= n and n <= max


def check_int_value(state: ParseState*, opt: Option, value: byte*, min: int, max: int) -> None:
    if value == NULL:
        fprintf(
            stderr, "%s: use '%s something' or '%s=something', not just '%s'\n",
            state.program_name, option_name(opt), option_name(opt), option_name(opt)
        )
        fail(state)

    if not is_valid_integer(value, min, max):
        fprintf(
            stderr, "%s: '%s' wants an integer between %d and %d, not '%s'\n",
            state.program_name, option_name(opt), min, max, value,
        )
        fail(state)


def parse_arg(state: ParseState*, seen: bool*, args: Args*) -> None:
    opt: Option
    value: byte*
    get_option_and_value(state, &opt, &value)

    if seen[opt as int]:
        fprintf(stderr, "%s: repeated option '%s'\n", state.program_name, option_name(opt))
        fail(state)
    seen[opt as int] = True

    match opt:
        case Option.Help:
            printf(HELP_TEXT, state.program_name)
            exit(0)
        case Option.NoColors:
            check_no_value(state, opt, value)
            args.color = False
        case Option.Pick:
            check_int_value(state, opt, value, 1, 13*4 - (1+2+3+4+5+6+7))
            args.pick = atoi(value)
        case Option.DiscardHide:
            check_no_value(state, opt, value)
            args.discardhide = True


@public
def parse_args(argv: byte**, args: Args*) -> None:
    *args = Args{color=True, pick=3, discardhide=False}

    state = ParseState{program_name=argv[0], remaining_args=&argv[1]}

    seen = [False, False, False, False]
    assert sizeof(seen)/sizeof(seen[0]) == NUM_OPTIONS

    while *state.remaining_args != NULL:
        parse_arg(&state, seen, args)


# Main function for tests: `jou -o foo src/args.jou` compiles an executable that runs this.
def main(argc: int, argv: byte**) -> int:
    args: Args
    parse_args(argv, &args)
    args.print()
    return 0
